<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml"
	schematypens="http://purl.oclc.org/dsdl/schematron"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:s="http://purl.oclc.org/dsdl/schematron">
   <teiHeader> 
      <fileDesc>
         <titleStmt>
            <title>ACDH-CH Dictionary Schema</title>
            <author>Charly Mörth</author>
            <author>Daniel Schopper</author>
         </titleStmt>
         <publicationStmt>
            <publisher>Austrian Centre for Digital Humanities and Cultural Heritage</publisher>
            <date>2021ff.</date>
         </publicationStmt>
         <sourceDesc>
            <p>This ODD is a customization of TEI Lex-0, adapted for the needs of the dictionaries produced at ACDH-CH.</p>
         </sourceDesc>
      </fileDesc>
      <revisionDesc>
         <change status="draft" when="2021-12-02">set up ODD, git repo and processing structure; incorporating most definitions from the VICAV dicts ODD, except for the prose part and the fvLib – TODO discuss if that is general enough to be included here or if it should be kept as a project/dictionary-specific vocabulary.</change>
      </revisionDesc>
   </teiHeader>
   <text>
      <front>
         <argument>
            <p>This TEI customization is a catch-all schema which comparable dictionaries encoded at the ACDH-CH should conform with. It serves two purposes: (1) It should define a compatibility layer between TEI Lex-0 – which it is based on – and legacy dictionaries (esp. VICAV), clearly defining where these dictionaries differ from Lex-0 while they are not ported to it; (2) in the future, it should define the baseline ODD which specific dictionaries should source and extend by their own rules, in order to define a schema which can be used for finer-grained validation.</p>
            <p>Being a derivate of TEI Lex-0, the documentation in this ODD only describes where it diverges from the cannonical TEI Lex-0 ODD.</p>
         </argument>
      </front>
      <body>
         <head>Documentation</head>
         <div>
            <head>Macrostructure</head>
            <p>The dictionaries covered by this schema are encoded according to the Guidelines of
               the Text Encoding Initiative (P5). They are conceptualised as a specific type of text
               and are therefore encoded with <gi>text</gi> elements. Each dictionary starts with a
                  <gi>teiHeader</gi> element which contains the metadata of the dictionary.</p>
            <p>The lexicographic data are placed in typed <gi>div</gi> elements. Thus, our TEI
               dictionaries basically look like this:</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples" valid="feasible">
               <TEI version="5.0">
                  <teiHeader> ... </teiHeader>
                  <text>
                     <body>
                        <div type="entries">
                           <entry>...</entry>
                           <entry>...</entry>
                        </div>
                        <div type="examples">
                           <cit type="example">...</cit>
                           <cit type="example">...</cit>
                        </div>
                     </body>
                  </text>
               </TEI>
            </egXML>
            <p>The <gi>body</gi> of a dictionary which conforms to this specification should contain
               two divisions: a series of entries within <tag>div type="entries"</tag> and a series
               of examples, encoded as <tag>div type="examples"</tag>. Examples are, as usual,
               encoded as <gi>cit</gi>/<gi>quote</gi> constructs. The rationale behind keeping
               example sentences outside the entries is to be able to reuse them in different parts
               of the dictionary.</p>
            <p>
                  <specDesc key="body"/>
                  <specDesc key="div"/>
            </p>
            <p>In order to encode that an example should be integrated into an entry, the construct <tag>ref type="example"</tag> is used as a direct child f</p>
         </div>
         <div>
            <head>Entries</head>
            <p>The content model of dictionary entries closely align with the specs of Lex-0.</p>
            <p>Unlike Lex-0, bibliographic references documenting the source of an entry (or parts of it) are attached at the end of this entry.</p>
            <!-- TODO -->
            <p><specDesc key="entry"/></p>
         </div>
         <div>
            <head>Language Identifiers</head>
            <p>All elements containing object language (lemmas, variants, inflected forms; including translations) must bear an <att>xml:lang</att> attribute. Thus, this ODD defines <att>xml:lang</att> as required on such elements.</p> 
         </div>
         <div>
            <head>Provenance and Status</head>
            <p>While usually changes of a TEI document are centrally documented in a <gi>revisionDesc</gi> element in the <gi>teiHeader</gi>, for technical reasons, we encode this information in-situ in each <gi>entry</gi> or example (<gi>cit</gi>). This information is collected at the end of each entry/example, as a series of feature structures (<tag>fs type="change"</tag>) which at least provide information of the parent records's status (<tag>f name="status"</tag>), the date of a change (<tag>f name="who"</tag>).</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples" valid="true">
               <fs type="change">​
                 <f name="who">​
                  <symbol value="stephan"/>​
                    </f>​
                 <f name="when">​
                  <symbol value="2014_09_17"/>​
                 </f>​
                 <f name="status">​
                  <symbol value="released"/>​
                 </f>​
               </fs>
            </egXML>
            <p>In some dictionaries, some statistics are collected within <gi>revisionDesc</gi>. For this <gi>measure</gi> within a <gi>change</gi> element is used:</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples">
               <change when="2018-09-11">
                  <measure type="records" quantity="48"/>
                  <measure type="entries" quantity="10"/>
                  <measure type="entryFrees" quantity="0"/>
                  <measure type="lemmas" quantity="10"/>
                  <measure type="releasedLemmas" quantity="0"/>
                  <measure type="mwus" quantity="0"/>
                  <measure type="cits" quantity="38"/>
                  <measure type="releasedCits" quantity="0"/>
                  <measure type="released" quantity="0"/>
               </change>
            </egXML>
            <p>In order to accomodate this information, the TEI Lex-0 schema is extended by adding the <gi>measure</gi> element.</p>
         </div>
         <div>
            <head>Legacy Encoding</head>
            <p>As mentioned before, this ODD also tries to document encoding practies which are yet to be ported to a more cannonical TEI Lex-0 structure.</p>
            <div>
               <head>Morphosyntactic annotations</head>
               <p>Inflected forms (<tag>form type="inflected"</tag>) in a pre-Lex-0-phase have been encoded in ana <att>ana</att> attribute on the respective <tag>form type="variant"</tag> containing a pointer to an entry in a central feature / feature value library (cf. Budin, Majewski &amp; Mörth 2012).</p>
            </div>
         </div>
         <div>
            <head>Further development</head>
            <p>As legacy dictionaries will be gradually ported to Lex-0, the legacy definitions in this ODD will be reduced.</p>
         </div>
         <div>
            <head>Using this ODD in a new project / dictionary</head>
            <p>Whenever you want to start a new project based on this </p>
         </div>
         <div>
            <head>Part 2: Formal Specification</head>
            
            <schemaSpec ident="acdh-ch-dicts" source="file:///home/danielschopper/data/generic-dict-schema/schema/tmp/TEILex0.compiled.odd">
               <moduleRef key="derived-module-TEILex0"/>

               <!-- We copy all modules from TEI Lex0 and exclude   -->
               <moduleRef key="analysis" except="c pc"/>
               <moduleRef key="core"/>
               <moduleRef key="dictionaries" except="hyph lbl syll pron"/>
               <moduleRef key="figures" except="figure"/>
               <moduleRef key="gaiji"/>
               <moduleRef key="header"/>
               <moduleRef key="linking"/>
               <moduleRef key="namesdates"/>
               <moduleRef key="tei"/>
               <moduleRef key="textstructure"/>
               
               <moduleRef key="transcr" except="metamark"/>
            
               <elementSpec ident="body" mode="change">
                  <desc>The main body of the dictionary. MUST include a <gi>div</gi> of type <val>entries</val> and MAY include a <gi>div</gi> of type <val>examples</val>.</desc>
                  <content>
                     <elementRef key="div" minOccurs="1" maxOccurs="2"/>
                  </content>
                  <constraintSpec ident="body-children" scheme="schematron">
                     <desc>assert typed div elements at the top of body</desc>
                     <constraint>
                        <s:rule context="tei:body">
                           <s:assert test="exists(tei:div[@type = 'entries'])">body must contain a div of type "entries".</s:assert>
                        </s:rule>
                     </constraint>
                  </constraintSpec>
               </elementSpec>
               <elementSpec ident="div" module="core" mode="change" xml:id="divSpec">
                  <constraintSpec ident="div-example-children" scheme="schematron">
                     <desc>assert content of top-level divisions</desc>
                     <constraint>
                        <s:rule context="tei:div[@type = 'examples']">
                           <s:assert test="every $e in * satisfies $e/self::tei:cit[@type = 'example']">div type="examples" may only contain cit type="example"</s:assert>
                        </s:rule>
                        <s:rule context="tei:div[@type = 'entries']">
                           <s:assert test="every $e in * satisfies $e/self::tei:entry">div type="entries" may only contain entry elements</s:assert>
                        </s:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="type" mode="replace" usage="req">
                        <valList type="closed">
                           <valItem ident="entries">
                              <desc>contains all entries in a dictionary</desc>
                           </valItem>
                           <valItem ident="examples">
                              <desc>contains examples used in the dictionary</desc>
                           </valItem>
                        </valList>
                     </attDef>   
                  </attList>
                  <exemplum>
                     <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        <TEI version="5.0">
                           <teiHeader> ... </teiHeader>
                           <text>
                              <body>
                                 <div type="entries">
                                    <entry>...</entry>
                                    <entry>...</entry>
                                 </div>
                                 <div type="examples">
                                    <cit type="example">...</cit>
                                    <cit type="example">...</cit>
                                 </div>
                              </body>
                           </text>
                        </TEI>
                     </egXML>
                  </exemplum>
               </elementSpec>               
            
               <!-- TEI Lex-0 adjustments to make the xsd deterministic 2024-06-26 -->
               <classSpec type="model" ident="model.hiLike" mode="change">
                  <classes mode="change">
                     <memberOf key="model.lexicalPhrase"  mode="delete"/>
                  </classes>
               </classSpec>
               <elementSpec ident="xr" mode="change">
                  <classes mode="change">
                     <memberOf key="model.quoteLike"  mode="delete"/>
                  </classes>
               </elementSpec>
               <elementSpec ident="lbl" mode="change">
                  <classes mode="change">
                     <memberOf key="model.emphLike"  mode="delete"/>
                  </classes>
               </elementSpec>
               <elementSpec ident="publicationStmt" mode="change">
                  <content>
                     <sequence>
                        <classRef key="model.publicationStmtPart.agency" minOccurs="1"
                           maxOccurs="unbounded"/>
                        <!-- elements model.publicationStmtPart.detail, except for availability, which is required in Lex-0 -->
                        <alternate minOccurs="0" maxOccurs="unbounded">
                           <classRef key="model.ptrLike"/>
                           <elementRef key="date"/>
                           <elementRef key="pubPlace"/>
                           <elementRef key="idno"/>
                        </alternate>
                        <elementRef key="availability"/>
                     </sequence>
                  </content>
               </elementSpec>
               
               <elementSpec ident="list" mode="change">
                  <content>
                     <sequence>
                        <classRef key="model.divTop" minOccurs="0"/>
                        <sequence minOccurs="1" maxOccurs="unbounded">
                           <elementRef key="label" minOccurs="0"/>
                           <elementRef key="item" minOccurs="1" maxOccurs="1"/>
                        </sequence>
                     </sequence>
                  </content>
               </elementSpec>
               <!-- end of ambiguity-fixing adjustments -->
               
            <!-- Additionally needed elements -->
            <moduleRef key="iso-fs" include="fs f symbol" source="https://www.tei-c.org/release/xml/tei/odd/p5subset.xml"/>
               
               <elementSpec ident="change" mode="change">
                  <content>
                     <alternate minOccurs="1" maxOccurs="1">
                        <elementRef key="measure"/>
                        <textNode/>
                     </alternate>
                  </content>
                  <exemplum>
                     <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        <change when="2018-09-11">
                           <measure type="records" quantity="48"/>
                           <measure type="entries" quantity="10"/>
                           <measure type="entryFrees" quantity="0"/>
                           <measure type="lemmas" quantity="10"/>
                           <measure type="releasedLemmas" quantity="0"/>
                           <measure type="mwus" quantity="0"/>
                           <measure type="cits" quantity="38"/>
                           <measure type="releasedCits" quantity="0"/>
                           <measure type="released" quantity="0"/>
                        </change>
                     </egXML>
                  </exemplum>
                  <remarks><p>can either contain a textual description or a series <gi>change</gi> elements with statistical prpoerties of the dictionary at a given point of time (<att>when</att>).</p></remarks>
               </elementSpec>
               
               <elementSpec ident="measure" source="https://www.tei-c.org/release/xml/tei/odd/p5subset.xml" mode="add" module="core">
                  <classes mode="replace">
                     <memberOf/>
                  </classes>
                  <exemplum>
                     <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        <change when="2018-09-11">
                           <measure type="records" quantity="48"/>
                           <measure type="entries" quantity="10"/>
                           <measure type="entryFrees" quantity="0"/>
                           <measure type="lemmas" quantity="10"/>
                           <measure type="releasedLemmas" quantity="0"/>
                           <measure type="mwus" quantity="0"/>
                           <measure type="cits" quantity="38"/>
                           <measure type="releasedCits" quantity="0"/>
                           <measure type="released" quantity="0"/>
                        </change>
                     </egXML>
                  </exemplum>
               </elementSpec>
               
               <elementRef key="interpretation" source="https://www.tei-c.org/release/xml/tei/odd/p5subset.xml"/>   

            <!-- 
               TODO We should have a finer-grained definition for <usg type="corpusFrequency">
               For the time being, I'm simply adding <q> and <val>.
               DS 2021-12-02
            -->
            <elementRef key="q" source="https://www.tei-c.org/release/xml/tei/odd/p5subset.xml"/>   
            <elementRef key="val" source="https://www.tei-c.org/release/xml/tei/odd/p5subset.xml"/>   

            <!-- TODO are we sure we want <mentioned> and <lb/> ? DS 2021-12-02-->
            <elementRef key="mentioned" source="https://www.tei-c.org/release/xml/tei/odd/p5subset.xml"/>
            <elementRef key="lb" source="https://www.tei-c.org/release/xml/tei/odd/p5subset.xml"/>
            
            <!-- 
               for some reason I had to explicitly add model.featureVal
               and make <symbol> a member of it. We should find out why. 
               DS 2021-12-02 
            -->
            <classRef key="model.featureVal" source="https://www.tei-c.org/release/xml/tei/odd/p5subset.xml"/>
            <elementSpec ident="symbol" mode="change">
               <classes mode="change">
                  <memberOf key="model.featureVal"/>
               </classes>
            </elementSpec>
            
            <classRef key="att.measurement" source="https://www.tei-c.org/release/xml/tei/odd/p5subset.xml"/>
            
            <elementSpec ident="ptr" mode="change" module="core">
               <constraintSpec ident="example-target" scheme="schematron">
                  <desc>rules that govern ptr elements</desc>
                  <constraint>
                     <s:rule context="tei:ptr[@type = 'example'][matches(@target,'^#') and not(contains(@target,' '))]">
                        <s:assert test="exists(root()//tei:cit[@type = 'example'][@xml:id = current()/substring-after(@target,'#')])">unknown example with id "<s:value-of select="current()/substring-after(@target,'#')"/>"</s:assert>
                     </s:rule>
                     <s:rule context="tei:ptr[@type = 'example'][not(matches(@target,'^#')) or contains(@target,' ')]">
                        <s:report test="count(tokenize(@target,'\s')[.!='']) > 1">only one pointer allowed in @target</s:report>
                        <s:report test="not(starts-with(normalize-space(@target),'#'))">unexpected value "<s:value-of select="current()/@target"/>": the value of @target must be a fragment identifier pointing to an xml:id of a dictionary example (tei:cit[@type='example'])</s:report>
                     </s:rule>
                  </constraint>
               </constraintSpec>
            </elementSpec>
            
            <elementSpec ident="seg" mode="change" module="linking">
               <constraintSpec ident="seg-context" scheme="schematron">
                  <desc>assert correct context of seg</desc>
                  <constraint>
                     <s:rule context="tei:seg[@type = 'hint']">
                        <s:assert test="parent::tei:quote[parent::tei:cit[@type = 'translation']]">a hint segment must be inside a translation equivalent</s:assert>
                     </s:rule>
                  </constraint>
               </constraintSpec>
               <attList>
                  <attDef ident="type" mode="replace" usage="req">
                     <valList type="closed">
                        <valItem ident="hint">
                           <desc>a hint in a translation to narrow down the semantic scope of the particular item.</desc>  
                        </valItem>
                        <valItem ident="constrPart">
                           <desc>TODO add description ???</desc>
                        </valItem>
                     </valList>
                  </attDef>
               </attList>
            </elementSpec>
               
               
<!--               
            <elementSpec ident="gram" mode="change" module="dictionaries">
               <attList>
                  <attDef ident="type" mode="change" usage="req">
                  <valList type="closed">
                     <valItem ident="arguments">
                        <desc>arguments to a verb</desc>
                     </valItem>
                     <valItem ident="aspect">
                        <desc>TODO description missing</desc>
                     </valItem>
                     <valItem ident="constraint">
                        <desc>describes an</desc>
                     </valItem>
                     <valItem ident="constr">
                        <desc>TODO description missing</desc>
                     </valItem>
                     <valItem ident="degree">
                        <desc>TODO description missing</desc>
                     </valItem>
                     <valItem ident="derivedVerbClass">
                        <desc>derived verb class</desc>
                        <remarks>
                           <p>In the VICAV dictionaries, we apply a mixed system of indicators mainly making use of the labels traditionally used in Arabic linguistics. In cases not covered by this system, we use labels analogous to Woidich 2006 (Das Kairenisch-Arabische).</p>
                        </remarks>
                     </valItem>
                     <valItem ident="extension"/>
                     <valItem ident="frequency">
                        <desc>TODO description missing</desc>
                     </valItem>
                     <valItem ident="gender">
                        <desc>grammatical gender</desc>
                     </valItem>
                     <valItem ident="government">
                        <desc>TODO description missing</desc>
                     </valItem>
                     <valItem ident="inflectionType">
                        <desc>inflection type</desc>
                     </valItem>
                     <valItem ident="mood">
                        <desc>grammatical mood</desc>
                     </valItem>
                     <valItem ident="morph">
                        <desc>TODO description missing</desc>
                     </valItem>
                     <valItem ident="morphPattern">
                        <desc>morphological pattern</desc>
                     </valItem>
                     <valItem ident="morphType">
                        <desc>mophological type</desc>
                        <remarks>
                           <p>Many Arabic dialects have nominals which do not display feminine or plural forms. These are identified with a gram element and a morphType attribute.</p>
                        </remarks>
                     </valItem>
                     <valItem ident="nominalState">
                        <desc>TODO description missing</desc>
                     </valItem>
                     <valItem ident="number">
                        <desc>grammatical number</desc>
                     </valItem>
                     <valItem ident="person">
                        <desc>TODO description missing</desc>
                     </valItem>
                     <valItem ident="pos">
                        <desc>part of speech type</desc>
                     </valItem>
                     <valItem ident="reg">
                        <desc>TODO description missing</desc>
                     </valItem>
                     <valItem ident="root">
                        <desc>consonantal root</desc>
                     </valItem>
                     
                     <valItem ident="subc">
                        <desc>subcategorization</desc>
                     </valItem>
                     
                     <valItem ident="usg">
                        <desc>hint on usage</desc>
                     </valItem>
                     
                     <valItem ident="synRoot">
                        <desc>synchronous root</desc>
                     </valItem>
                     <valItem ident="diaRoot">
                        <desc>diachronic root</desc>
                     </valItem>
                     <valItem ident="diaRootNew">
                        <desc>TODO description missing</desc>
                     </valItem>
                  </valList>
               </attDef>
               </attList>
            </elementSpec>            
            -->
               
            <!-- DS 2024-05-27: allowing placeName inside of usg as found in SHAWI dictionaries - 
               CHECKME: Do we want to include this here or is it specific to SHAWI ? -->
            <!-- changed placeName to name -->
            <elementSpec ident="usg" mode="change">
               <content>
                  <alternate>
                     <elementRef key="name" minOccurs="0" maxOccurs="unbounded"/>
                     <macroRef key="macro.lexicalParaContent"/>
                  </alternate>
               </content>
               <constraintSpec ident="name-in-usg" scheme="schematron">
                  <desc>assert that only usg type geographic contain a name element</desc>
                  <constraint>
                     <s:rule context="tei:usg[not(@type = 'geographic') and not(@type='socioCultural')]">
                        <s:report test="exists(tei:name)">the name element must only occur inside of usg elements with @type="geographic" or @type="socioCultural".</s:report> 
                     </s:rule>
                  </constraint>
               </constraintSpec>
            </elementSpec>
            
            <elementSpec ident="cit" mode="change" module="core">
               <!--<content>
                  <alternate minOccurs="1" maxOccurs="unbounded">
                     <!-\- both examples or translations have their textual content enclosed in quote elements -\->
                     <elementRef key="quote" minOccurs="1" maxOccurs="1"/>
                     <!-\- example entries may have 1–n nested translations -\->
                     <elementRef key="cit" minOccurs="0" maxOccurs="unbounded"/>
                     <!-\- Change history of examples are recorded in <fs> elements. -\->
                     <elementRef key="fs"/>
                     
                     <elementRef key="bibl"/>
                     
                     <elementRef key="note"/>
                     <elementRef key="sense"/>
                     <elementRef key="usg"/>
                     <elementRef key="xr"/>
                     <elementRef key="def"/>
                     <elementRef key="ptr"/>
                     <elementRef key="ref"/>
                     <elementRef key="gramGrp"/>
                     <!-\- ADDED DS 2024-05-26 -\->
                     <!-\-we should align the content more closely to the content in Lex0-\->
                     <elementRef key="form"/>
                  </alternate>
               </content>-->
               <constraintSpec ident="cit-context" scheme="schematron">
                  <desc>assert correct context of cit types</desc>
                  <constraint>
                     <s:rule context="tei:cit[@type = 'translation']">
                        <s:report test="* except (tei:quote|tei:usg[@type = 'hint']|tei:bibl)">a translation equivalent may only contain 1) the translated text in a quote element, 2) a usage hint and/or 3) a bibliographic reference to the source of the translation.</s:report>
                     </s:rule>
                     <s:rule context="tei:cit[@subtype = 'proverb']">
                        <s:assert test="@type = 'example'">unexpected value "<s:value-of select="current()/@type"/>" in @type – a proverb must be encoded as cit type="example" subtype="proverb"</s:assert>
                     </s:rule>
                  </constraint>
               </constraintSpec>
               <attList>
                  <attDef ident="type" mode="change" usage="req">
                     <valList type="closed" mode="change">
                        <valItem ident="literalTranslation" mode="add">
                           <desc>literal translation</desc>
                           <remarks><p>Added for backwards compatibility.</p></remarks>
                        </valItem>
                        <valItem ident="cognate" mode="delete"/>
                        <valItem ident="cognateSet" mode="delete"/>
                     </valList>
                  </attDef>
                  <attDef ident="subtype" mode="replace" usage="opt">
                     <valList type="closed">
                        <valItem ident="proverb">
                           <desc>proverb</desc>
                        </valItem>
                        <valItem ident="scientificName">
                           <desc>Scientific Name</desc>
                           <remarks><p>Being sourced from controlled vocabularies, scientific Names are a special kind of translation equivalent.</p></remarks>
                        </valItem>
                        <valItem ident="verbatim">
                           <desc>TODO description missing</desc>
                        </valItem>
                     </valList>
                  </attDef>
               </attList>
            </elementSpec>
               
               
               <elementSpec ident="ref" mode="change" module="core">
                  <desc>a reference either to a license or to an example</desc>
                  <content>
                     <empty/>
                  </content>
                  <constraintSpec ident="ref" scheme="schematron">
                     <constraint>
                        <s:rule context="tei:ref[@type = 'example']">
                           <s:assert test="exists(substring-after(.,':'))">Example with id "<s:value-of select="exists(//tei:cit[@type='example'][@xml:id=substring-after(current()/@target,'#')])"/>" not found</s:assert>
                        </s:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="type" mode="change">
                        <valList type="closed">
                           <valItem ident="license" mode="add">
                              <desc>license</desc>
                           </valItem>
                           <valItem ident="example">
                              <desc>example</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
                  <remarks><p>In case of <val>example</val>, the <att>target</att> attribute should contain a pointer to a <tag>cit type="example"</tag>.</p></remarks>
               </elementSpec>
               <!--<elementSpec ident="placeName" mode="change" module="namesdates">
                  <
               </elementSpec>
            -->
            <elementSpec ident="form" mode="change" module="dictionaries">
               <constraintSpec ident="form-type" scheme="schematron">
                  <desc>assert content of correct context of @type values</desc>
                  <constraint>
                     <s:rule context="tei:form[@type = 'variant']">
                        <s:assert test="parent::tei:form[@type = ('lemma','multiWordUnit', 'inflected')]">a variant must be a direct child of the main form (type = "lemma", "multiWordUnit" or "inflected").</s:assert>
                     </s:rule>
                     <s:rule context="tei:form[@type = 'lemma']">
                        <s:assert test="parent::tei:entry">a headword must be a direct child of an entry element. </s:assert>
                     </s:rule>
                  </constraint>
               </constraintSpec>
               <attList>
                  <!-- TODO In Zulu , there are <form>s without @type inside 
                     of cit type translation 
                     HOW TO treat? 2021-12-11 DS
                  -->
                  <attDef ident="type" mode="replace" usage="req">
                     <valList type="closed">
                        <valItem ident="lemma">
                           <desc>the headword of a lemma entry</desc>
                        </valItem>
                        <valItem ident="multiWordUnit">
                           <desc>the headword of a MWU entry</desc>
                        </valItem>
                        
                        <valItem ident="inflected">
                           <desc>inflected form</desc>
                        </valItem>
                        <!-- WHAT IS @type='infl' ? 
                    121 in baghdad dict, many empty orth elements
                    112 in apc
                -->
                        <!--<valItem ident="infl">
                    <desc>????</desc>
                </valItem>-->
                        
                        
                        <!-- WHEN IS THIS USED ? 16 instances in damascus dict  -->
                        <valItem ident="example">
                           <desc>???</desc>
                        </valItem>
                        
                        <valItem ident="variant">
                           <desc>A variant form of the lemma. Only headwords may have variants. All other variants – e.g. competing morphological forms – are simply listed but not classified. Variants can be assigned usage labels indicating e.g. a particular register. The more frequent variant should precede less frequent ones. </desc>
                        </valItem>
                        
                        <valItem ident="stem">
                           <desc>TODO description missing</desc>
                        </valItem>
                        
                        <valItem ident="derived">
                           <desc>TODO description missing</desc>
                        </valItem>
                        
                        <!-- in how far is @type = "lemmaVariant" different from @type = 'variant'? -->
                        <valItem ident="lemmaVariant">
                           <desc>TODO description missing</desc>
                        </valItem>
                        
                        <!-- WHEN IS THIS USED ?? -->
                        <valItem ident="construction">
                           <desc>TODO description missing</desc>
                        </valItem>
                        
                        <valItem ident="VN">
                           <desc>TODO description missing</desc>
                        </valItem>
                        
                        <valItem ident="infinitive">
                           <desc>TODO description missing</desc>
                        </valItem>
                        
                        <valItem ident="adverbial">
                           <desc>TODO description missing</desc>
                        </valItem>
                        
                       
                        <valItem ident="abbreviation">
                           <desc>TODO description missing</desc>
                        </valItem>
                        
                       
                        <!-- TODO DS 2021-12-02 
                           These @types look complex – we should describe why 
                           they are different from the other "flat" values -->
                        <valItem ident="lexicalType:adverb">
                           <desc>TODO description missing</desc>
                        </valItem>
                        <valItem ident="lexicalType:infinitive">
                           <desc>TODO description missing</desc>
                        </valItem>
                        <valItem ident="lexicalType:infinitiveLocative">
                           <desc>TODO description missing</desc>
                        </valItem>
                        <valItem ident="grammaticalCase:genitive">
                           <desc>TODO description missing</desc>
                        </valItem>
                        <valItem ident="grammaticalCase:vocative">
                           <desc>TODO description missing</desc>
                        </valItem>
                        
                     </valList>
                  </attDef>
               </attList>
            </elementSpec>
         </schemaSpec>
         </div>
      </body>
   </text>
</TEI>
